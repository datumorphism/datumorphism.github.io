<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Computation on Datumorphism</title><link>https://datumorphism.leima.is/categories/computation/</link><description>Recent content in Computation on Datumorphism</description><generator>Hugo -- gohugo.io</generator><language>en-US</language><lastBuildDate>Fri, 08 Jan 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://datumorphism.leima.is/categories/computation/index.xml" rel="self" type="application/rss+xml"/><item><title>Basics of Computation</title><link>https://datumorphism.leima.is/wiki/computation/basics-of-computation/</link><pubDate>Thu, 13 Sep 2018 00:00:00 +0000</pubDate><guid>https://datumorphism.leima.is/wiki/computation/basics-of-computation/</guid><description>Storage, Precision, Error, etc To have some understanding of how the numbers are processed in computers, we have to understand how the numbers are stored first.
Computers stores everything in binary form 1. Suppose we randomly get some segments in the memory, we have no idea what that stands for since we do not know the type of data it represents.
Some of the most used data types in data science are
integer, float, string, time. Integers Integers can occupy $2^0$, $2^1$, $2^2$, $2^3$ bytes in memory.
1 byte : | | | | | | | | | 2 bytes: | | | | | | | | | | | | | | | | | 4 bytes: | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | .</description></item><item><title>Basics of Programming</title><link>https://datumorphism.leima.is/wiki/computation/basics-of-programming/</link><pubDate>Sun, 23 Sep 2018 00:00:00 +0000</pubDate><guid>https://datumorphism.leima.is/wiki/computation/basics-of-programming/</guid><description>Recursive and Iterative Solving problems with iterative and recursive methods are two quite different approaches, somehow, to the same kind of problems.
Here we will calculate the factorial of $n$. We define two functions using the iterative method and the recursive method.
Run the program on Repl.it.
def recursiveFactorial(n): if n == 0: return 1 else: return n * recursiveFactorial(n - 1) def iterativeFactorial(n): ans = 1 i=1 while i &amp;lt;= n: ans = ans * i i=i+1 return ans print(recursiveFactorial(0)) print(iterativeFactorial(0))</description></item><item><title>Basics of Network</title><link>https://datumorphism.leima.is/wiki/computation/basics-of-network/</link><pubDate>Sun, 23 Sep 2018 00:00:00 +0000</pubDate><guid>https://datumorphism.leima.is/wiki/computation/basics-of-network/</guid><description>HTTP Keywords Hyper Text Transfer Protocal: deliver hyper text from server to local browser etc. Based on TCP/IP Current version: HTTP/2 Server - Client Client can request through GET, HEAD, POST, PUT, DELETE, TRACE, OPTIONS, CONNECT, PATCH. Transfer anything defined by Content-Type Connectionless Protocol: doesn&amp;rsquo;t maintain the connection all the time Stateless protocal: A very nice explanation URL Keywords Uniform Resource Locator Interpret each part of this URL: http://abc.com:8000/folder/file.html#title1location?param1=123&amp;amp;param2=234 No limits on length of URL by HTTP itself. However, some servers or clients do set limits. Difference between URI and URL and URN: The Difference Between URLs and URIs checkout the Venn diagram.</description></item><item><title>Basics of Database</title><link>https://datumorphism.leima.is/wiki/computation/basics-of-database/</link><pubDate>Wed, 03 Oct 2018 00:00:00 +0000</pubDate><guid>https://datumorphism.leima.is/wiki/computation/basics-of-database/</guid><description>NoSQL NoSQL = Not only SQL. The four main types of NoSQL databases are
Key-value store: Amazon Dynamo, memcached, Amazon SimpleDB Column-orient store: Google BigTable, Cassandra Graph database: Neo4j, VertexDB Document database: MongoDB Object database: ZODB Database Operations Relations Union: $A\cup B$ Intersection: $A\cap B$ $A - B$ Cartesian Product: $A \times B$ Query Union in database: will combine the data with matching common columns.
NaturalJoin and EquiJoin:
--EquiJoin where we specify what condition is used to join SELECT * FROM table1 JOIN table2 ON (table1.id = table2.id) --NaturalJoin where conditions are chosen by the database automatically SELECT * FROM table1 NATURAL JOIN table2 Procedural language: derived from structural programming, focuses on breaking tasks into variables, data structures, and subroutines.</description></item><item><title>Basics of SQL</title><link>https://datumorphism.leima.is/wiki/computation/basics-of-sql/</link><pubDate>Mon, 19 Nov 2018 00:00:00 +0000</pubDate><guid>https://datumorphism.leima.is/wiki/computation/basics-of-sql/</guid><description>Adding a new field to data:
Relational: requires a new column Non-Relational: just add the field to one single document, thus can be easily decentralized. Basics and Background SQL: Structured Query Language
Relational Database:
usually in tables rows are called records columns are certain types of data. Data types of rows are specified: INTEGER TEXT DATE REAL, real numbers NULL &amp;hellip; RDBMS: Relational Database Management System, most RDBMS use SQL as the query language. SQLite is one of the RDBMS.
SQLite: open source and minimal MySQL: powerful and popular, also open source, controlled by Oracle, not really scalable.</description></item><item><title>Basics of MongoDB</title><link>https://datumorphism.leima.is/wiki/computation/basics-of-mongodb/</link><pubDate>Wed, 03 Oct 2018 00:00:00 +0000</pubDate><guid>https://datumorphism.leima.is/wiki/computation/basics-of-mongodb/</guid><description>This MongoDB Cheatsheet is my best friend.
MongoDB Concepts Documents Collections: just like tables in SQL. Database MongoShell Some examples:
// show the databases show dbs // show collections show collections //set any database to current database use database_name // insert entry db.database_name.insert( an_object_2_be_the_entry ) // read document db.database_name.findOne({'some_field':'value_of_field'}) db.database_name.fidn() // prettify db.database_name.find().pretty()</description></item><item><title>Basics of Redis</title><link>https://datumorphism.leima.is/wiki/computation/basics-of-redis/</link><pubDate>Fri, 08 Jan 2021 00:00:00 +0000</pubDate><guid>https://datumorphism.leima.is/wiki/computation/basics-of-redis/</guid><description>Basics Redis is:
NoSQL KeyValue In memory Data Structure Server binary safe strings lists, sets, sorted sets, hashes bitmaps, hyperloglogs Open source Redis is:
Fast Low CPU Requirement Scalable Redis can be used as:
Cache Analytics Leaderboard Queues Cookie storage Expiring data Messaging High I/O workloads API throttlings How to persist your data
Snapshot AOF: Append Only File Pros:
Redis has both data store and job queue built in Redis is a data structure server so is has flexibe data structures Redis is fast Cons:
Redis used a lot of RAM Redis can be be queued by value Comparisons</description></item></channel></rss>