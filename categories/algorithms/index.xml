<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Algorithms on Datumorphism</title><link>https://datumorphism.leima.is/categories/algorithms/</link><description>Recent content in Algorithms on Datumorphism</description><generator>Hugo -- gohugo.io</generator><language>en-US</language><lastBuildDate>Thu, 18 Jan 2024 00:00:00 +0000</lastBuildDate><atom:link href="https://datumorphism.leima.is/categories/algorithms/index.xml" rel="self" type="application/rss+xml"/><item><title>Decimal to Binary Representation</title><link>https://datumorphism.leima.is/wiki/algorithms/practices/decimal-to-binary/</link><pubDate>Thu, 18 Jan 2024 00:00:00 +0000</pubDate><guid>https://datumorphism.leima.is/wiki/algorithms/practices/decimal-to-binary/</guid><description>from typing import Tuple, List class Decimal2Base: &amp;#34;&amp;#34;&amp;#34;Given an integer in decimal representation, find the binary representation. Example: Input: 5 Output: 101 &amp;#34;&amp;#34;&amp;#34; def __init__(self, base: int = 2): self.base = base def _quotient_remainder(self, n: int) -&amp;gt; Tuple[int, int]: return (n // self.base, n % self.base) def _digits(self, number: int, digits: List) -&amp;gt; List: &amp;#34;&amp;#34;&amp;#34;Recursively find the binary representation of a number. &amp;#34;&amp;#34;&amp;#34; if number == 0: return digits else: quotient, remainder = self._quotient_remainder(number) digits = [remainder] + digits return self._digits(quotient, digits) def __call__(self, number: int) -&amp;gt; List: digits: List = [] return self._digits(number, digits) def test_decimal2binary(): decimal2binary = Decimal2Base(base=2) assert decimal2binary(5) == [1, 0, 1] def test_decimal2decimal(): decimal2decimal = Decimal2Base(base=10) assert decimal2decimal(5) == [5] assert decimal2decimal(14) == [1, 4]</description></item><item><title>Some Basic Ideas of Algorithms</title><link>https://datumorphism.leima.is/wiki/algorithms/algorithms-basics/</link><pubDate>Tue, 20 Mar 2018 00:00:00 +0000</pubDate><guid>https://datumorphism.leima.is/wiki/algorithms/algorithms-basics/</guid><description>This set of notes on algorithms is not meant to be comprehensive or complete. These notes are being used as a skeleton framework. There are many useful books to learn about algorithms from a utilitarian point of view. I have listed a few in the references section.
Numerical recipes1 is a very comprehensive book that I used during my PhD. It covers almost all the algorithms you need for scientific computing.
Grokking Algorithms2 is another good book to learn the basics of algorithms. It is barely entry level but is fun to read.
An Outline Data Structure mind the data structure Basics of MapReduce mapreduce numrec Press, W.</description></item><item><title>Target Sum</title><link>https://datumorphism.leima.is/wiki/algorithms/practices/target-sum/</link><pubDate>Thu, 18 Jan 2024 00:00:00 +0000</pubDate><guid>https://datumorphism.leima.is/wiki/algorithms/practices/target-sum/</guid><description>Two Sum from typing import List, Literal class TwoSum: &amp;#34;&amp;#34;&amp;#34;Find all the possible combinations of two numbers in a list that sum up to a target integer. Example: Input: nums = [2, 7, 11, 15], target = 9 Output: [[2, 7]] &amp;#34;&amp;#34;&amp;#34; def __init__(self, method: Literal[&amp;#34;brute_force&amp;#34;]) -&amp;gt; None: self.method = method def __call__(self, nums: List, target: int) -&amp;gt; List: &amp;#34;&amp;#34;&amp;#34; :param nums: list of integers :param target: target integer &amp;#34;&amp;#34;&amp;#34; if self.method == &amp;#34;brute_force&amp;#34;: return self._brute_force_two_sum(nums, target) def _brute_force_two_sum(self, nums: List, target: int) -&amp;gt; List: &amp;#34;&amp;#34;&amp;#34;Find all the possible combinations of two numbers in a list that sum up to a target integer.</description></item><item><title>Data Structure</title><link>https://datumorphism.leima.is/wiki/algorithms/data-structure/</link><pubDate>Tue, 20 Mar 2018 00:00:00 +0000</pubDate><guid>https://datumorphism.leima.is/wiki/algorithms/data-structure/</guid><description>Dealing with data structure is like dealing with your clothes. Some people randomly drop their clothes somewhere without thinking. But it takes time to retrieve a specific T-shirt. Some people spend more time folding and arranging their clothes. This process makes it easy to find a specific T-shirt. Similar to retrieving clothes, there is always a balance between the computation time (retrieving clothes) and the coding time (folding clothes).
Some Useful Data Structures This section serves as some kind of flashcard keywords. I am using this section to remind myself of the important concepts.
Binary Tree [[Tree]] Data Structure: Tree mind the data structure: here comes the tree ; Binary tree Traverse a tree: Pre-order traversal: parent-&amp;gt;left-&amp;gt;right In-orer traversal: left-&amp;gt;parent-&amp;gt;right Post-order traversal: left-&amp;gt;right-&amp;gt;parent Level-order traversal: top-&amp;gt;bottom, by each level from left to right of the whole tree Array Suppose I bought 5 movie tickets for the movie Tenet.</description></item><item><title>Data Structure: Tree</title><link>https://datumorphism.leima.is/wiki/algorithms/data-structure-tree/</link><pubDate>Tue, 27 Mar 2018 00:00:00 +0000</pubDate><guid>https://datumorphism.leima.is/wiki/algorithms/data-structure-tree/</guid><description>mind the data structure: here comes the tree</description></item><item><title>Data Structure: Graph</title><link>https://datumorphism.leima.is/wiki/algorithms/data-structure-graph/</link><pubDate>Tue, 27 Mar 2018 00:00:00 +0000</pubDate><guid>https://datumorphism.leima.is/wiki/algorithms/data-structure-graph/</guid><description>mind the data structure: here comes the graph</description></item><item><title>Signal Processing</title><link>https://datumorphism.leima.is/wiki/algorithms/singal-processing/</link><pubDate>Tue, 20 Mar 2018 00:00:00 +0000</pubDate><guid>https://datumorphism.leima.is/wiki/algorithms/singal-processing/</guid><description>There are many fascinating ideas in signal processing.</description></item><item><title>Signal Processing: Audio Basics</title><link>https://datumorphism.leima.is/wiki/algorithms/signal-processing-audio/</link><pubDate>Thu, 29 Mar 2018 00:00:00 +0000</pubDate><guid>https://datumorphism.leima.is/wiki/algorithms/signal-processing-audio/</guid><description>Keywords Harmonic structure of sound Parson code of music Linear time-invariant theory Autocorrelation Noise Chirps DCT compression Discrete Fourier transform filtering convolution Linear Time-Invariant System We describe the system with $Y(t) = f(X(t))$, where $X(t)$ is the input, and $Y(t)$ is the output.
Linear: $f(a X_1(t) + b X_2(t)) = a f(X_1(t)) + b f(X_2(t))$ Time-invariant: input $X(t+\Delta t)$ will produce the shifted signal $Y(t+\Delta t)$. LTI systems are memory systems, casual, real, and stable. Stable means the output won&amp;rsquo;t reach infinite if the input is finite. It&amp;rsquo;s bounded.
Impulse Response Suppose we have a impulse $X(t) = I(t)$, and output $h(t)$.</description></item><item><title>Basics of MapReduce</title><link>https://datumorphism.leima.is/wiki/algorithms/map-reduce/</link><pubDate>Wed, 03 Oct 2018 00:00:00 +0000</pubDate><guid>https://datumorphism.leima.is/wiki/algorithms/map-reduce/</guid><description>Centralized servers are not efficient for big data. Querying and processing data on centralized servers would reach bottleneck of the servers.
MapReduce is used to solve these problems of big data. The two videos are .
Map: take series of key-value pairs and divide them into groups. Reduce: recombine the key-value pairs Checkout the code challenges of MapReduce on HackerRank.</description></item></channel></rss>