<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>wiki/graph/basics/what-is-graph.md on Datumorphism</title><link>https://datumorphism.leima.is/links/wiki/graph/basics/what-is-graph.md/</link><description>Recent content in wiki/graph/basics/what-is-graph.md on Datumorphism</description><generator>Hugo -- gohugo.io</generator><language>en-US</language><atom:link href="https://datumorphism.leima.is/links/wiki/graph/basics/what-is-graph.md/index.xml" rel="self" type="application/rss+xml"/><item><title>Statistics of Graphs</title><link>https://datumorphism.leima.is/wiki/graph/basics/statistics-of-graphs/</link><pubDate>Sat, 25 Sep 2021 00:00:00 +0000</pubDate><guid>https://datumorphism.leima.is/wiki/graph/basics/statistics-of-graphs/</guid><description>Local Statistics Node Degree Node Degree Node degree of a node $u$ $$ d_u = \sum_{v\in \mathcal V} A[u,v], $$ where $A$ is the adjacency matrix. Node Centrality Importance of a node on a graph:
Eigenvector Centrality of a Graph Given a graph with adjacency matrix $\mathbf A$, the eigenvector centrality is $$ \mathbf e_u = \frac{1}{\lambda} \sum_{v\in\mathcal V} \mathbf A[u,v] \mathbf e_v, \qquad \forall u \in \mathcal V. $$ Why is it called Eigenvector Centrality The definition is equivalent to $$ \lambda \mathbf e = \mathbf A\mathbf e. $$ Power Iteration The solution to $\mathbf e$ is the eigenvector that corresponds to the largest eigenvalue $\lambda_1$.</description></item><item><title>Solving Problems on Graph</title><link>https://datumorphism.leima.is/wiki/graph/basics/ml-problems-on-graph/</link><pubDate>Sat, 25 Sep 2021 00:00:00 +0000</pubDate><guid>https://datumorphism.leima.is/wiki/graph/basics/ml-problems-on-graph/</guid><description>Graphs can be used in many problem and there are many possible problems on graphs. We will mention a few popular problems on graphs12.
Node Classification Is the user in black a bot or a normal user?Created based on the text in Hamilton2020
Given graph that has incomplete attribute labeling of the nodes, predict the attributes on the nodes.
The following concepts can be used to classify nodes.
Homophily Homophily on Graph Homophily is the principle that a contact between similar people occurs at ahigher rate than among dissimilar people &amp;ndash; McPherson20011 McPherson2001 McPherson M, Smith-Lovin L, Cook JM.</description></item><item><title>Graph Convolution Operator</title><link>https://datumorphism.leima.is/cards/graph/graph-convolution-operator/</link><pubDate>Thu, 25 Nov 2021 00:00:00 +0000</pubDate><guid>https://datumorphism.leima.is/cards/graph/graph-convolution-operator/</guid><description>For a given graph $\mathcal G$, we have an attribute on each node, denoted as $f_v$. All the node attributes put together can be written as a list $\mathbf f\to (f_{v_1}, f_{v_2}, \cdots, f_{v_N})$.
Convolution on graph is combining attributes on nodes with their neighbors'. The adjacency matrix Graph Adjacency Matrix A graph $\mathcal G$ can be represented with an adjacency matrix $\mathbf A$. There are some nice and clear examples on wikipedia1, for example, $$ \begin{pmatrix} 2 &amp; 1 &amp; 0 &amp; 0 &amp; 1 &amp; 0\\ 1 &amp; 0 &amp; 1 &amp; 0 &amp; 1 &amp; 0\\ 0 &amp; 1 &amp; 0 &amp; 1 &amp; 0 &amp; 0\\ 0 &amp; 0 &amp; 1 &amp; 0 &amp; 1 &amp; 1\\ 1 &amp; 1 &amp; 0 &amp; 1 &amp; 0 &amp; 0\\ 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 \end{pmatrix} $$ for the graph Public Domain, Link $\mathbf A$ applied on all node attributes $\mathbf f$ is such an operation, i.</description></item><item><title>Betweenness Centrality of a Graph</title><link>https://datumorphism.leima.is/cards/graph/graph-betweenness-centrality/</link><pubDate>Sat, 25 Sep 2021 00:00:00 +0000</pubDate><guid>https://datumorphism.leima.is/cards/graph/graph-betweenness-centrality/</guid><description>Betweenness centrality of a node $v$ is measurement of how likely the shortest path between two nodes $u_s$ and $u_t$ is gonna pass through node $v$,
$$ c(v) = \sum_{v\neq u_s\neq u_t} \frac{\sigma_{u_su_t}(v) }{\sigma_{u_su_t}}, $$
where $\sigma_{u_su_t}(v)$ is the number of shortest path between $u_s$ and $u_t$, and passing through $u$, while $\sigma_{u_su_t}$ is the number of shortest path between $u_s$ and $u_t$.
A figure from wikipedia demonstrates this idea well. The nodes on the outreach have smaller betweenness centrality, while the nodes in the core have higher betweenness centrality.
Source: Wikipedia
Outreach and Core
It is almost like cheating using the work &amp;ldquo;outreach&amp;rdquo; and &amp;ldquo;core&amp;rdquo; here.</description></item><item><title>Eigenvector Centrality of a Graph</title><link>https://datumorphism.leima.is/cards/graph/graph-eigenvector-centrality/</link><pubDate>Sat, 25 Sep 2021 00:00:00 +0000</pubDate><guid>https://datumorphism.leima.is/cards/graph/graph-eigenvector-centrality/</guid><description>Given a graph with adjacency matrix $\mathbf A$, the eigenvector centrality is
$$ \mathbf e_u = \frac{1}{\lambda} \sum_{v\in\mathcal V} \mathbf A[u,v] \mathbf e_v, \qquad \forall u \in \mathcal V. $$
Why is it called Eigenvector Centrality
The definition is equivalent to
$$ \lambda \mathbf e = \mathbf A\mathbf e. $$
Power Iteration The solution to $\mathbf e$ is the eigenvector that corresponds to the largest eigenvalue $\lambda_1$. Power iteration method can help us get this eigenvector, i.e., the $^{(t+1)}$ iteration is related to the previous iteration $^{(t)}$, through the following relation,
$$ \mathbf e^{(t+1)} = \mathbf A \mathbf e^{(t)}.</description></item><item><title>Graph Adjacency Matrix</title><link>https://datumorphism.leima.is/cards/graph/graph-adjacency-matrix/</link><pubDate>Sat, 25 Sep 2021 00:00:00 +0000</pubDate><guid>https://datumorphism.leima.is/cards/graph/graph-adjacency-matrix/</guid><description>A graph $\mathcal G$ can be represented with an adjacency matrix $\mathbf A$. There are some nice and clear examples on wikipedia1, for example,
$$ \begin{pmatrix} 2 &amp; 1 &amp; 0 &amp; 0 &amp; 1 &amp; 0\\ 1 &amp; 0 &amp; 1 &amp; 0 &amp; 1 &amp; 0\\ 0 &amp; 1 &amp; 0 &amp; 1 &amp; 0 &amp; 0\\ 0 &amp; 0 &amp; 1 &amp; 0 &amp; 1 &amp; 1\\ 1 &amp; 1 &amp; 0 &amp; 1 &amp; 0 &amp; 0\\ 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 \end{pmatrix} $$
for the graph
Public Domain, Link</description></item><item><title>Node Degree</title><link>https://datumorphism.leima.is/cards/graph/node-degree/</link><pubDate>Sat, 25 Sep 2021 00:00:00 +0000</pubDate><guid>https://datumorphism.leima.is/cards/graph/node-degree/</guid><description>Node degree of a node $u$
$$ d_u = \sum_{v\in \mathcal V} A[u,v], $$
where $A$ is the adjacency matrix.</description></item><item><title>Weisfeiler-Lehman Kernel</title><link>https://datumorphism.leima.is/cards/graph/graph-weisfeiler-lehman-kernel/</link><pubDate>Sat, 25 Sep 2021 00:00:00 +0000</pubDate><guid>https://datumorphism.leima.is/cards/graph/graph-weisfeiler-lehman-kernel/</guid><description>The Weisfeiler-Lehman kernel is an iterative integration of neighborhood information.
We initialize the labels for each node using its own node degree. At each step, we take the neighboring node degrees to form a multiset. At step $K$, we have the multisets for each node. Those multisets at each node can be processed to form an representation of the graph which is in turn used to calculate statistics of the graph.
Iterate $k$ steps
This iteration can be used to test if two graphs are isomorphism1.
Shervashidze2011 Shervashidze N, Schweitzer P, van Leeuwen EJ, Mehlhorn K, Borgwardt KM.</description></item><item><title>Popularity versus similarity in growing networks</title><link>https://datumorphism.leima.is/reading/popularity-vs-similarity/</link><pubDate>Sun, 06 Nov 2016 00:00:00 +0000</pubDate><guid>https://datumorphism.leima.is/reading/popularity-vs-similarity/</guid><description>Introduce geometry into the manifold of complex networks</description></item></channel></rss>