<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Code Challenges on Datumorphism</title><link>https://datumorphism.leima.is/tags/code-challenges/</link><description>Recent content in Code Challenges on Datumorphism</description><generator>Hugo -- gohugo.io</generator><language>en-US</language><lastBuildDate>Thu, 18 Jan 2024 00:00:00 +0000</lastBuildDate><atom:link href="https://datumorphism.leima.is/tags/code-challenges/index.xml" rel="self" type="application/rss+xml"/><item><title>Decimal to Binary Representation</title><link>https://datumorphism.leima.is/wiki/algorithms/practices/decimal-to-binary/</link><pubDate>Thu, 18 Jan 2024 00:00:00 +0000</pubDate><guid>https://datumorphism.leima.is/wiki/algorithms/practices/decimal-to-binary/</guid><description>from typing import Tuple, List class Decimal2Base: &amp;#34;&amp;#34;&amp;#34;Given an integer in decimal representation, find the binary representation. Example: Input: 5 Output: 101 &amp;#34;&amp;#34;&amp;#34; def __init__(self, base: int = 2): self.base = base def _quotient_remainder(self, n: int) -&amp;gt; Tuple[int, int]: return (n // self.base, n % self.base) def _digits(self, number: int, digits: List) -&amp;gt; List: &amp;#34;&amp;#34;&amp;#34;Recursively find the binary representation of a number. &amp;#34;&amp;#34;&amp;#34; if number == 0: return digits else: quotient, remainder = self._quotient_remainder(number) digits = [remainder] + digits return self._digits(quotient, digits) def __call__(self, number: int) -&amp;gt; List: digits: List = [] return self._digits(number, digits) def test_decimal2binary(): decimal2binary = Decimal2Base(base=2) assert decimal2binary(5) == [1, 0, 1] def test_decimal2decimal(): decimal2decimal = Decimal2Base(base=10) assert decimal2decimal(5) == [5] assert decimal2decimal(14) == [1, 4]</description></item><item><title>Target Sum</title><link>https://datumorphism.leima.is/wiki/algorithms/practices/target-sum/</link><pubDate>Thu, 18 Jan 2024 00:00:00 +0000</pubDate><guid>https://datumorphism.leima.is/wiki/algorithms/practices/target-sum/</guid><description>Two Sum from typing import List, Literal class TwoSum: &amp;#34;&amp;#34;&amp;#34;Find all the possible combinations of two numbers in a list that sum up to a target integer. Example: Input: nums = [2, 7, 11, 15], target = 9 Output: [[2, 7]] &amp;#34;&amp;#34;&amp;#34; def __init__(self, method: Literal[&amp;#34;brute_force&amp;#34;]) -&amp;gt; None: self.method = method def __call__(self, nums: List, target: int) -&amp;gt; List: &amp;#34;&amp;#34;&amp;#34; :param nums: list of integers :param target: target integer &amp;#34;&amp;#34;&amp;#34; if self.method == &amp;#34;brute_force&amp;#34;: return self._brute_force_two_sum(nums, target) def _brute_force_two_sum(self, nums: List, target: int) -&amp;gt; List: &amp;#34;&amp;#34;&amp;#34;Find all the possible combinations of two numbers in a list that sum up to a target integer.</description></item></channel></rss>