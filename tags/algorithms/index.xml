<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Algorithms on Datumorphism</title><link>https://datumorphism.leima.is/tags/algorithms/</link><description>Recent content in Algorithms on Datumorphism</description><generator>Hugo -- gohugo.io</generator><language>en-US</language><lastBuildDate>Thu, 18 Jan 2024 00:00:00 +0000</lastBuildDate><atom:link href="https://datumorphism.leima.is/tags/algorithms/index.xml" rel="self" type="application/rss+xml"/><item><title>Decimal to Binary Representation</title><link>https://datumorphism.leima.is/wiki/algorithms/practices/decimal-to-binary/</link><pubDate>Thu, 18 Jan 2024 00:00:00 +0000</pubDate><guid>https://datumorphism.leima.is/wiki/algorithms/practices/decimal-to-binary/</guid><description>from typing import Tuple, List class Decimal2Base: &amp;#34;&amp;#34;&amp;#34;Given an integer in decimal representation, find the binary representation. Example: Input: 5 Output: 101 &amp;#34;&amp;#34;&amp;#34; def __init__(self, base: int = 2): self.base = base def _quotient_remainder(self, n: int) -&amp;gt; Tuple[int, int]: return (n // self.base, n % self.base) def _digits(self, number: int, digits: List) -&amp;gt; List: &amp;#34;&amp;#34;&amp;#34;Recursively find the binary representation of a number. &amp;#34;&amp;#34;&amp;#34; if number == 0: return digits else: quotient, remainder = self._quotient_remainder(number) digits = [remainder] + digits return self._digits(quotient, digits) def __call__(self, number: int) -&amp;gt; List: digits: List = [] return self._digits(number, digits) def test_decimal2binary(): decimal2binary = Decimal2Base(base=2) assert decimal2binary(5) == [1, 0, 1] def test_decimal2decimal(): decimal2decimal = Decimal2Base(base=10) assert decimal2decimal(5) == [5] assert decimal2decimal(14) == [1, 4]</description></item><item><title>Some Basic Ideas of Algorithms</title><link>https://datumorphism.leima.is/wiki/algorithms/algorithms-basics/</link><pubDate>Tue, 20 Mar 2018 00:00:00 +0000</pubDate><guid>https://datumorphism.leima.is/wiki/algorithms/algorithms-basics/</guid><description>This set of notes on algorithms is not meant to be comprehensive or complete. These notes are being used as a skeleton framework. There are many useful books to learn about algorithms from a utilitarian point of view. I have listed a few in the references section.
Numerical recipes1 is a very comprehensive book that I used during my PhD. It covers almost all the algorithms you need for scientific computing.
Grokking Algorithms2 is another good book to learn the basics of algorithms. It is barely entry level but is fun to read.
An Outline Data Structure mind the data structure Basics of MapReduce mapreduce numrec Press, W.</description></item><item><title>Monte Carlo</title><link>https://datumorphism.leima.is/wiki/monte-carlo/</link><pubDate>Wed, 03 Feb 2021 00:00:00 +0000</pubDate><guid>https://datumorphism.leima.is/wiki/monte-carlo/</guid><description/></item><item><title>Basics of MapReduce</title><link>https://datumorphism.leima.is/wiki/algorithms/map-reduce/</link><pubDate>Wed, 03 Oct 2018 00:00:00 +0000</pubDate><guid>https://datumorphism.leima.is/wiki/algorithms/map-reduce/</guid><description>Centralized servers are not efficient for big data. Querying and processing data on centralized servers would reach bottleneck of the servers.
MapReduce is used to solve these problems of big data. The two videos are .
Map: take series of key-value pairs and divide them into groups. Reduce: recombine the key-value pairs Checkout the code challenges of MapReduce on HackerRank.</description></item></channel></rss>