<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Algorithms Practices on Datumorphism</title><link>https://datumorphism.leima.is/wiki/algorithms/practices/</link><description>Recent content in Algorithms Practices on Datumorphism</description><generator>Hugo -- gohugo.io</generator><language>en-US</language><lastBuildDate>Thu, 18 Jan 2024 00:00:00 +0000</lastBuildDate><atom:link href="https://datumorphism.leima.is/wiki/algorithms/practices/index.xml" rel="self" type="application/rss+xml"/><item><title>Decimal to Binary Representation</title><link>https://datumorphism.leima.is/wiki/algorithms/practices/decimal-to-binary/</link><pubDate>Thu, 18 Jan 2024 00:00:00 +0000</pubDate><guid>https://datumorphism.leima.is/wiki/algorithms/practices/decimal-to-binary/</guid><description>from typing import Tuple, List class Decimal2Base: &amp;#34;&amp;#34;&amp;#34;Given an integer in decimal representation, find the binary representation. Example: Input: 5 Output: 101 &amp;#34;&amp;#34;&amp;#34; def __init__(self, base: int = 2): self.base = base def _quotient_remainder(self, n: int) -&amp;gt; Tuple[int, int]: return (n // self.base, n % self.base) def _digits(self, number: int, digits: List) -&amp;gt; List: &amp;#34;&amp;#34;&amp;#34;Recursively find the binary representation of a number. &amp;#34;&amp;#34;&amp;#34; if number == 0: return digits else: quotient, remainder = self._quotient_remainder(number) digits = [remainder] + digits return self._digits(quotient, digits) def __call__(self, number: int) -&amp;gt; List: digits: List = [] return self._digits(number, digits) def test_decimal2binary(): decimal2binary = Decimal2Base(base=2) assert decimal2binary(5) == [1, 0, 1] def test_decimal2decimal(): decimal2decimal = Decimal2Base(base=10) assert decimal2decimal(5) == [5] assert decimal2decimal(14) == [1, 4]</description></item></channel></rss>